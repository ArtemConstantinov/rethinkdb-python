# Copyright 2018-present RethinkDB
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use
# this file except in compliance with the License. You may obtain a copy of the
# License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.
#
# This file incorporates work covered by the following copyright:
#
#     Copyright 2010-present, The Linux Foundation, portions copyright Google and
#     others and used with permission or subject to their respective license
#     agreements.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

'''
Take a .proto file as input and output the a definitions file for a
supported language: javascript, python, ruby

Usually the input file should be ../src/rdb_protocol/ql2.proto
'''
from __future__ import annotations
from dataclasses import dataclass
import optparse
import os
from pathlib import Path
import re
import sys
import io
from typing import Generator


@dataclass(frozen=True)
class LangDef:
    initialIndentLevel: int
    header: str
    separator: str
    open: str
    value: str
    empty: str | None
    close: str | None
    closeAlwaysNewLine: bool
    footer: str


LANGUAGE_DEFS = {
    "python": LangDef(
        initialIndentLevel=0,
        header="# DO NOT EDIT\n# Autogenerated by %s\n" % os.path.basename(__file__),
        separator="",
        open="\n%(tabs)sclass %(name)s:",
        value="\n%(tabs)s%(name)s = %(value)s",
        empty="pass",
        close=None,
        closeAlwaysNewLine=False,
        footer="\n"
    ),
    "ruby": LangDef(
        initialIndentLevel=1,
        header="# DO NOT EDIT\n# Autogenerated by %s\n\nmodule RethinkDB" % os.path.basename(__file__),
        separator="",
        open="\n%(tabs)smodule %(name)s",
        value="\n%(tabs)s%(name)s = %(value)s",
        empty=None,
        close="end",
        closeAlwaysNewLine=True,
        footer="\nend\n"
    ),
    "javascript": LangDef(
        initialIndentLevel=1,
        header="// DO NOT EDIT\n// Autogenerated by %s\n\nmodule.exports = {" % os.path.basename(__file__),
        separator=", ",
        open="\n%(tabs)s%(name)s: {",
        value="\n%(tabs)s%(name)s: %(value)s",
        empty=None,
        close="}",
        closeAlwaysNewLine=False,
        footer="\n}\n"
    )
}


def convert_file(inputFile: io.TextIOWrapper, language: str) -> Generator[str, None, None]:
    assert (inputFile is not None and hasattr(inputFile, 'read'))
    assert (language in LANGUAGE_DEFS)

    messageRegex = re.compile(r'\s*(message) (?P<name>\w+) \{')
    enumRegex = re.compile(r'\s*(enum) (?P<name>\w+) \{')
    valueRegex = re.compile(r'\s*(?P<name>\w+)\s*=\s*(?P<value>\w+)')
    endRegex = re.compile(r'\s*\}')

    _lang = LANGUAGE_DEFS[language]
    indentLevel = _lang.initialIndentLevel
    lastIndentLevel = _lang.initialIndentLevel - 1

    # -- write headers

    yield _lang.header

    # -- convert the body

    levelHasContent = False

    for line in inputFile:
        # - open
        match = messageRegex.match(line)
        if match is not None:
            if indentLevel == lastIndentLevel:
                yield _lang.separator

            if levelHasContent:
                yield "\n" + "\t" * indentLevel

            yield _lang.open % {
                'tabs': "\t" * indentLevel,
                'name': match.group('name')
            }
            lastIndentLevel = indentLevel
            indentLevel += 1
            levelHasContent = False
            continue

        # - value
        match = valueRegex.match(line)
        if match is not None:
            if indentLevel == lastIndentLevel:
                yield _lang.separator
            value = match.group('value')
            if value.startswith('0x'):
                value = int(value, 0)
            yield _lang.value % {
                'tabs': "\t" * indentLevel,
                'name': match.group('name'),
                'value': value,
            }
            lastIndentLevel = indentLevel
            levelHasContent = True
            continue

        # - close
        match = endRegex.match(line)
        if match is not None:
            if not levelHasContent and _lang.empty is not None:
                yield "\n" + "\t" * indentLevel + _lang.empty

                lastIndentLevel = indentLevel
            if _lang.close is not None:
                if indentLevel == lastIndentLevel or _lang.closeAlwaysNewLine is True:
                    yield "\n" + "\t" * (indentLevel - 1)
                yield _lang.close
            indentLevel -= 1
            lastIndentLevel = indentLevel
            levelHasContent = True

    # -- write footer
    yield _lang.footer


def define_parser() -> optparse.OptionParser:
    parser = optparse.OptionParser()
    parser.add_option(
        "-l", "--language",
        dest="language",
        help="write output for language",
        metavar="LANG",
        choices=list(LANGUAGE_DEFS.keys()),
        default=None,
    )
    parser.add_option(
        "-i", "--input-file",
        dest="inputFile",
        help="read from FILE (default STDIN)",
        metavar="FILE",
        default=None,
    )
    parser.add_option(
        "-o", "--output-file",
        dest="outputFile",
        help="write to FILE (default STDOUT)",
        metavar="FILE",
        default=None,
    )
    return parser


def main() -> None:
    parser = define_parser()
    (options, args) = parser.parse_args()

    if options.language is None:
        parser.error("A language option is required")

    # input_buff = io.StringIO(sys.stdin.read())
    if options.inputFile:
        input_path = Path(options.inputFile)
        if not input_path.is_file():
            parser.error(f"Unable to open the given input file <<{input_path}>>")
        with input_path.open('r') as in_f:
            input_buff = io.StringIO(in_f.read())

        output_buff = io.StringIO()
        for line in convert_file(input_buff, options.language):
            output_buff.write(line)

        print(output_buff.getvalue())

    # if options.outputFile:
    #     try:
    #         with Path(options.inputFile).open("w") as out_f:
    #             out_f.write(output_buff.getvalue())
    #     except Exception:
    #         parser.error(f"Unable to open the given output file <<{options.inputFile}>>")
    # else:
    #     sys.stdout.write(output_buff.getvalue())


if __name__ == '__main__':
    main()
